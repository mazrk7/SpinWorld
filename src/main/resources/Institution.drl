package spinworld

import java.lang.Math
import java.util.Collections
import java.util.List
import java.util.ArrayList
import java.util.Iterator

import spinworld.actions.*
import spinworld.facts.*
import spinworld.network.*
import spinworld.RoundType
import spinworld.Globals
import spinworld.GraduationLevel
import spinworld.LeftNetwork

global org.apache.log4j.Logger logger
global java.util.Random rnd

declare Violation
	@role(event)
	particle : Particle	@key
	network : spinworld.network.Network	@key
	time : int	@key
	severity : double
	on : String
end

declare Monitored
	@role(event)
	particle : Particle	@key
	network : spinworld.network.Network	@key
	time : int	@key
end

declare Sanction
	@role(event)
	particle : Particle	@key
	network : spinworld.network.Network	@key
	time : int	@key
	level : GraduationLevel
end

declare Observation
	@role(event)
	particle : Particle	@key
	observed : Particle	@key
	network : spinworld.network.Network	@key
	time : int	@key
end

declare TaskComplete
	@role(event)
	task : String	@key
	time : int	@key
end

query compliantRound(Network n, Particle p, int $t)
	not(exists(Violation($p, $n, $t;)))
end

rule "Monitor particles"
	salience 5 // After provision
	no-loop
	when
		Round($t : number, type == RoundType.DEMAND)
		not TaskComplete("monitoring", $t;)
		$n : Network(monitoringLevel > 0)
		$pool : ProvisionPool(network == $n)
		$alp : AllocationPool(network == $n)
		$poolMembers : List(size > 0) from accumulate(MemberOf(network == $n, $p : particle), collectList($p))
	then
		int toMonitor = (int) Math.ceil($poolMembers.size() * $n.getMonitoringLevel());
		logger.info($n.toString() + ": Attempting to monitor " + toMonitor + " particles.");
		
		List members = new ArrayList($poolMembers);
		Collections.shuffle(members);
		Iterator it = members.iterator();
		double resources = $pool.getQuantity();
			
		while(resources > $n.getMonitoringCost() && toMonitor-- > 0 && it.hasNext()) {
			Particle p = (Particle) it.next();
			Monitored m = new Monitored(p, $n, $t);
			insert(m);
			resources -= $n.getMonitoringCost(); 
			logger.info(m);
		}
		
		modify($pool) {
			setQuantity(resources);
		}
		
		modify($alp) {
			setQuantity(resources);
		} 
		
		logger.info("Pool is now: " + $pool);
		insert(new TaskComplete("monitoring", $t));
end

rule "Sanction particles"
	salience 2 // After monitoring & detection of cheating
	when 
		Round($t : number, type == RoundType.APPROPRIATE)
		Violation($p : particle, $n : network, time == $t, $s : severity)
		$m : MemberOf(network == $n, particle == $p)
	then	
		if($s >= $n.getSeverityUB() || ($n.getWarningCount($p) >= $n.getNoWarnings()
				&& $s >= $n.getSeverityLB() && $s < $n.getSeverityUB())) {	
			$p.updateObservedSanctionHistory(GraduationLevel.EXPULSION);
			
			Sanction sanc = new Sanction($p, $n, $t, GraduationLevel.EXPULSION);
			insert(sanc);
			logger.info(sanc);	
			
			retract($m);
			insert(new LeftNetwork($n));
			logger.info("Expulsion: " + $p + " from " + $n);
			$n.banParticle($p);
		} else if($s >= $n.getSeverityLB() && $s < $n.getSeverityUB()) {
			$p.updateObservedSanctionHistory(GraduationLevel.WARNING);
			$n.warn($p);
			
			Sanction sanc = new Sanction($p, $n, $t, GraduationLevel.WARNING);
			insert(sanc);
			logger.info(sanc);	
		} else if($s < $n.getSeverityLB()) {	
			$p.updateObservedSanctionHistory(GraduationLevel.NO_SANCTION);
				
			Sanction sanc = new Sanction($p, $n, $t, GraduationLevel.NO_SANCTION);
			insert(sanc);
			logger.info(sanc);
		} 
			
		double mFreq = $n.getMonitoringLevel();
		mFreq = mFreq + $s * (1-mFreq);
		$n.setMonitoringLevel(mFreq);
end

rule "Reduce monitoring frequency"
	salience 5
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		$n : Network()
		exists(MemberOf(network == $n))
		not(exists(Violation($p : particle, network == $n, time == $t, $s : severity)))
	then
		double mFreq = $n.getMonitoringLevel();
		
		mFreq = mFreq - 0.1 * mFreq;
		$n.setMonitoringLevel(mFreq);
end

rule "Observation of network sanctioning"
	salience 1 // After sanctioning
	when 
		Round($t : number, type == RoundType.APPROPRIATE)
		Sanction($pSanc : particle, $n : network, time == $t, $l : level)
		$m : MemberOf(network == $n, $p : particle)
	then		
		if (!$pSanc.equals($p)) {
			$p.updateObservedCatchHistory(Boolean.TRUE);	
			$p.updateObservedSanctionHistory($l);
				
			Observation obsv = new Observation($p, $pSanc, $n, $t);
			insert(obsv);
			logger.info(obsv);
		}
end	
	
rule "Detect cheat on provision"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		$provision : Provision(particle == $p, t == $t, quantity < $g)
	then
		Violation v = new Violation($p, $n, $t);
		v.setSeverity($g - $provision.getQuantity());
		v.setOn("provision");
		
		logger.info(v);
		insert(v);
end

rule "Could not detect cheat on provision"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		not Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		Provision(particle == $p, t == $t, quantity < $g)
	then
		$p.updateObservedCatchHistory(Boolean.FALSE);	
end

rule "Detect cheat on demand"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		$demand : Demand(particle == $p, t == $t, quantity > $q)
	then	
		Violation v = new Violation($p, $n, $t);
		v.setSeverity($demand.getQuantity() - $q);
		v.setOn("demand");
		
		logger.info(v);
		insert(v);
end

rule "Could not detect cheat on demand"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		not Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		Demand(particle == $p, t == $t, quantity > $q)
	then
		$p.updateObservedCatchHistory(Boolean.FALSE);
end

rule "Detect cheat on appropriate"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		Allocate($r : quantity, particle == $p, t == $t)
		$approp : Appropriate($rP : quantity, particle == $p, t == $t, quantity > $r)
	then	
		Violation v = new Violation($p, $n, $t);
		v.setSeverity($approp.getQuantity() - $r);
		v.setOn("appropriate");
		
		logger.info(v);
		insert(v);
end

rule "Could not detect cheat on appropriate"
	salience 3
	when
		Round($t : number, type == RoundType.APPROPRIATE)
		MemberOf($p : particle, $n : network)
		not Monitored($p, $n, $t ;)
		Generate(t == $t, $g : g, $q : q, particle == $p)
		Allocate($r : quantity, particle == $p, t == $t)
		Appropriate($rP : quantity, particle == $p, t == $t, quantity > $r)	
	then
		$p.updateObservedCatchHistory(Boolean.FALSE);		
end

rule "Prune monitored"
	when
		Round($t : number)
		$m : Monitored($t > time + 10)
	then
		retract($m);
end

rule "Prune tasks"
	when
		Round($t : number)
		$n : TaskComplete($t > time + 10)
	then
		retract($n);
end
